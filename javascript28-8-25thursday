
//3 major keywords (var,let,const) to declare variable:
var a=10
var a=20  -var allows Re-declaration but can't use let or const keyword
a=30      -var also allows Re-assignment

let a=10 
let a=20  - let doesn't allow Re-declaration
a=30      - let allows Re-assignment

const a=10 
const a=20  -doesn't allow Re-declaration
a=20        -doesn't allow Re-assignment
//const doesn't allow redeclaration,reassignment

-------------------------------------------------------------------- 
//Data Types: 
(i) Primitive - number ,string,boolean, undefined, null, arrays, objects but Number,String,Boolean wrapper class constructor
(ii)Non-Primitive - Array, Object

let x;
console.log(x) //undefined
console.log(typeof x) //undefined
-----------------------------------------
let y = null;	
console.log(y) //null
console.log(typeof y)// object
------------------------------------------
let list = [1,2,3,4, "Java", false, null]
console.log(list) 
console.log(typeof list) // object
------------------------------------------
Object: key-value pair
let obj = {name: "ps", age:30, hasPassport:false}
console.log(typeof obj)//object
-------------------------------------------------------
console.log(typeof x)//undefined
console.log(typeof y)//object
console.log(typeof list)//object
console.log(typeof obj)//object
console.log(typeof undefined) //undefined

Everything in javascript is object
--------------------------------------------------------------------------
//Arithmetic operators - as the name suggests it works only on numbers
logical operators
comparison operators
//Precedence-    />* >+>- 
100 / 5 * 2= 40âœ”ï¸  but 10âŒ. From left to right associativity.since both have same precedence.

//multiplication & division > subtraction & addition

//Concatination
console.log("javascript" + 10) //javascript10 
console.log(typeof("javascript" + 10)) // string
console.log("20" + "10") //2010
console.log(typeof("20" + "10")) //string
concationation(string+number) //=string
-------------------------------------------------------

//type coersin
let Momos = 100
let samosa = "50"
console.log(Momos +samosa)//10050
//that's why use- type coersion

-------------------------------------------
//Q: Declare a number, a string
//Try to use + operator on them
//Try to use - operator on them
//Try to use * / operator them
//console.log(value and typeof)
------------------------------------------
let a = 10;
let b = "20";
let b="abc" Nan(Not a number in case of * / . but type of(Nan) is number)

// Using + (concatenation happens when one is string)
console.log(a + b, typeof (a + b));   // "1020" string

// Using - (JavaScript tries to convert string to number)
console.log(a - b, typeof (a - b));   // -10 number (javascript using implicit type coersin here)

// Using * and / (again, string is converted to number)
console.log(a * b, typeof (a * b));   // 200 (number)
console.log(a / b, typeof (a / b));   // 0.5 (number)
---------------------------------------------------------------------------------------------------
//explicit if i do coersin

a=10
b="10"
//comparison operator
console.log(a == b)//true value checking loose equality
console.log(a === b)//false type checking strict equality

logical operators in javascript run from left
console.log(false || true && false)// -> false && true=true
----------------------------------------------------------
let x =10
let y = typeof x
console.log(typeof y)//string

*****************************************************************************************************
let a = 10 + "20";
console.log(a); //1020

// 10 (number) + "20" (string) â†’ 
// JS converts number to string when + is used.
// So "10" + "20" â†’ "1020" (string).
-------------------------------------------------------
console.log("5" * 2 + "1"); //101

// "5" * 2 â†’ here * forces numeric conversion. "5" â†’ 5.
// So 5 * 2 = 10.
// Now 10 + "1" â†’ 10 (number) gets converted to string because + with string â†’ "10" + "1" = "101"
----------------------------------------------------------------------------------------------------
console.log("10" - "7" + 3); //6

In JavaScript, both - (subtraction) and + (addition) are
left-to-right associative operators with the same precedence.
So the expression is evaluated from left to right.
// "10" - "7" â†’ both strings are converted to numbers when - is used.
// So 10 - 7 = 3.
// Now 3 + 3 = 6 (both numbers, so normal addition).
-----------------------------------------------------------------------------------------
console.log( null == undefined, null === undefined ); // true false

// ðŸ‘‰ == â†’ loose equality, allows type coercion. In JS, null == undefined is true.
// ðŸ‘‰ === â†’ strict equality, no type coercion. null and undefined are different types.
// So result: true false
// Output: true false
------------------------------------------------------------------------------------------
console.log( [] + 1, [1] + 1 ); //1 11

// [] + 1 â†’ empty array [] is converted to an empty string "" when used with +.
// So "" + 1 = "1".
// [1] + 1 â†’ [1] converts to string "1".
// So "1" + 1 = "11".
// Output: "1" "11"
-------------------------------------------------------------------------------------------------
let x; 
console.log(typeof x, typeof y); //undefined undefined

// let x; means x is declared but not initialized, so value = undefined.
// typeof x â†’ undefined.
// y is not declared at all. Normally referencing undeclared variables throws ReferenceError, 
but typeof y is special â€” it does not throw error, instead it returns undefined.

-------------------------------------------------------------------------------------------------------------------------------------
js_basics_90min.js

'use strict';
const user = { name: "Bicky", age: "29", active: "true", scores: ["10", "20", 30], meta: null };
const A = "10", B = 10, C = "42", D = 0, E = undefined, F = null, G = NaN;
const obj = { "key-1": 1, nested: { x: "2", y: 3 }, "weird prop": "ok" };
------------------------------------------------------
// B1
const isFortyTwoString = C==="42"
console.log(isFortyTwoString); // true
-----------------------------------------------------
// B2
const sumAB= Number(A) + B
console.log(sumAB); // 20
------------------------------------------------------
// B3
const concatAB= A+B*2
console.log(concatAB) // 1020
--------------------------------------------------------
// B4
const nestedSum = Number(obj.nested.x) +obj.nested.y
console.log(nestedSum)// 3+2= 5
-------------------------------------------------------
B5 (5 marks). Safe numbers & booleans. From user, create ageNum as a number, and activeBool as a boolean (non-empty string â†’ true).
const ageNum= Number(user.age)    // "29" â†’ 29
const activeBool= Boolean(user.active) // "true" -> true
console.log(ageNum)
console.log(activeBool)
-----------------------------------------------------------
Q6 (5 marks). Prevent accidental concatenation (alt coercion).
Create safeTotal that adds A and B to get 20 but without using Number(A). Use a different explicit coercion method.

const safeTotal = Numner(A)+B // +A converts "10" â†’ 10
console.log(safeTotal)
---------------------------------------------------------

Q7 (4 marks). Equality snapshots. Create variables:
p1Loose, p1Strict for 10 vs "10"
p2Loose, p2Strict for null vs undefined Log them in one line.

const p1Loose = (10 == "10");      // true
const p1Strict = (10 === "10");    // false

const p2Loose = (null == undefined);   // true
const p2Strict = (null === undefined); // false

console.log(p1Loose, p1Strict, p2Loose, p2Strict);

console.log('DONE');




// === in JS is strict equality:
// Checks both type and value.
// "42" (string) is not equal to 42 (number).
// "42 " (extra space) is not equal either.
// Only when the input is exactly the string "42", it returns true.

// console.log('DONE');

***************************************************************************************
//Control flow:
if-else:

let rice = "perfect"
if(rice === "perfect"{
 console.log("Eat the biryani")
}else if(){
 console.log("Cook for some more time")
}else{
 console.log(""Ordre from Zomato")
}
if(true){
 console.log("Hello")
}else if(true){
   console.log("Hi")
}//whenever first time condition is true then it will ignore the remaining condition
whichever condition has higher piority it should be given first like
if there are two different if then it will run both.
---------------------------------------------------------------------------------------
//Switch Case:
switch(expression){
    case value1:
    case value2:
    case value3:
}
let day="Tuesday"
switch(day){
    case "Monday":
        console.log("Today is Monday")
    case "Tuesday":
        console.log("Today is Monday")
    default:
        console.log("None of the above")
}

---------------------------------------------------------------
Loops:
for (initialization; condition;increment/decrement){
}
for (let i=0;true;){
//this will run for infinity
}
for (let i=0;i<5; i=i+1){ 
//it will go infinite loop if i not give increment/decrement
   console.log(i)
}//0 1 2 3 4  ( vertically)
------------
let i=0;
while(i<=5){
 console.log(i)
 i++
}
----------------
let i=0
do{
 console.log(i)
 i++
}while(i > 5)
//run the code first
//then checks for condition
------------------------------------------------
//initioalization -> Starting point let i=0
check for condition
if true runs the code
increment/decrement
if false
then stop
------------------------
break/continue keyword
it will skip this
let eaten = 0
for(let plate=1; plate<=10; plate++){
  if(plate == 3){
      continue
  }
if(eaten >= 5){
  break
}
  console.log("Eatong Plate", plate)
  eaten++
}
-----------------------------------------------
function:
functionName(parameters){
 //code
}
functionName(arguments)

function add(a,b){
 let sum =a+b
 return sum
}
console.log(add(5, 10))
console.log(add(25, 100))
console.log(add(50, 210))
---------------------
function greet(){
  console.log("Hello")
  return "Hi"
}
console.log(greet()) //undefined

Parameter: passed during function declaration
argument:- passed during function calling

//Undefined is data type
function greet(){
  console.log("Hello")
  return "Hi"
}
console.log(greet())
--------------------------------------------------------------------
Javascript runs in 2 phase- Memory allocation phase Execution phase
what is hoisting in js?
console.log(x) //undefined
var x=20  //var default value in memory allocation
console.log(x)
let a=10
const b=5

add(2,3)  //skip in memory allocation

console.log(a)//5  //skip in memory allcation
function add(a,b=0){
console.log(a,b) //2 3
let sum =a+b
return sum
memory : x=undefined, a, b  add: function(a,b){....}
20 
2 3
5
10

function expression
const add = (a,b=0)=> a+b
add(2,3)
  //logic
  return

//function declaration function expression

**************************************************************************************************************
function printTable(num){
  for (i=1;i<=10;i++){
  // console.log(num +" x " +i +" = "+ num*i)
  //using backticks to build string directly with placeholders ${},
  // instead of concatination(+) or commas(,), This is the modern ES6+ standard way.
   console.log(`${num} x ${i} = ${num * i}`)
  }
}
printTable(5)
// In string concatination(+), all parts are combined into one single string value,
// before being sent to console.log.
//
// In contrast, when you use commas(,) 
// console.log just takes multiple argumnets.
// it doesn't join them into one string, it prints each with a space in between.
// Performance-wise:
// If you care about micro-speed â†’ use commas are slightly faster,
// If you care about readable output â†’ use +.

---------------------------------------------------------------
function countDigits(num) {
  const newNum = num.toString()
  return newNum.length
}
console.log(countDigits(987654)); // 6












