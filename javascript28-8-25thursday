
//3 major keywords (var,let,const) to declare variable:
var a=10
var a=20  -var allows Re-declaration but can't use let or const keyword
a=30      -var also allows Re-assignment

let a=10 
let a=20  - let doesn't allow Re-declaration
a=30      - let allows Re-assignment

const a=10 
const a=20  -doesn't allow Re-declaration
a=20        -doesn't allow Re-assignment
//const doesn't allow redeclaration,reassignment

-------------------------------------------------------------------- 
//Data Types: 
(i) Primitive - number ,string,boolean, undefined, null, arrays, objects but Number,String,Boolean wrapper class constructor
(ii)Non-Primitive - Array, Object

let x;
console.log(x) //undefined
console.log(typeof x) //undefined
-----------------------------------------
let y = null;	
console.log(y) //null
console.log(typeof y)// object
------------------------------------------
let list = [1,2,3,4, "Java", false, null]
console.log(list) 
console.log(typeof list) // object
------------------------------------------
Object: key-value pair
let obj = {name: "ps", age:30, hasPassport:false}
console.log(typeof obj)//object
-------------------------------------------------------
console.log(typeof x)//undefined
console.log(typeof y)//object
console.log(typeof list)//object
console.log(typeof obj)//object
console.log(typeof undefined) //undefined

Everything in javascript is object
--------------------------------------------------------------------------
//Arithmetic operators - as the name suggests it works only on numbers
logical operators
comparison operators
//Precedence-    />* >+>- 
100 / 5 * 2= 40✔️  but 10❌. From left to right associativity.since both have same precedence.

//multiplication & division > subtraction & addition

//Concatination
console.log("javascript" + 10) //javascript10 
console.log(typeof("javascript" + 10)) // string
console.log("20" + "10") //2010
console.log(typeof("20" + "10")) //string
concationation(string+number) //=string
-------------------------------------------------------

//type coersin
let Momos = 100
let samosa = "50"
console.log(Momos +samosa)//10050
//that's why use- type coersion

-------------------------------------------
//Q: Declare a number, a string
//Try to use + operator on them
//Try to use - operator on them
//Try to use * / operator them
//console.log(value and typeof)
------------------------------------------
let a = 10;
let b = "20";
let b="abc" Nan(Not a number in case of * / . but type of(Nan) is number)

// Using + (concatenation happens when one is string)
console.log(a + b, typeof (a + b));   // "1020" string

// Using - (JavaScript tries to convert string to number)
console.log(a - b, typeof (a - b));   // -10 number (javascript using implicit type coersin here)

// Using * and / (again, string is converted to number)
console.log(a * b, typeof (a * b));   // 200 (number)
console.log(a / b, typeof (a / b));   // 0.5 (number)
---------------------------------------------------------------------------------------------------
//explicit if i do coersin

a=10
b="10"
//comparison operator
console.log(a == b)//true value checking loose equality
console.log(a === b)//false type checking strict equality

logical operators in javascript run from left
console.log(false || true && false)// -> false && true=true
----------------------------------------------------------
let x =10
let y = typeof x
console.log(typeof y)//string
----------------4-09-25-------------------------------------------------------------------------------
let arr = new Array(5) //constructor
let list = ["a", "b", "c", "d"] ''literal

JS has a 0 based
console.log(list[2]) //c
console.log(list[0]) //a

//methods :
//push add element to the end
let char ="e"
list.push("e")
console.log(list.push("e")) //5
console.log(list) // ['a', 'b', 'c', 'd', 'e']

//pop -removes from the end
console.log(list.pop())//e
console.log(list)// ['a', 'b', 'c', 'd']

//shift -removes from the front
list.shift()
console.log(list)

//unshift
list.unshift("a")
console.log(list)

list fruits = ["apple", "banana", "orange" , "grapes", "pineapple"]
fruits.pop() //["apple", "banana", "orange" , "grapes"]

//splice- index , number
fruits.splice(1, 2)// ["apple", "grapes", "pineapple"]
console.log(fruits)

splice - starting index , number of items
let deletdeFruits =fruits.splice(2)
console.log(fruits)
console.log(deletedFruits)

fruits[1] = "kiwi"
console.log(fruits)// ["apple","kiwi", "banana", "orange" , "grapes", "pineapple"]

let numbers–[10,20,30]
let n = fruits.length
for(let i=0; i<n; i++){
    numbers[i]=numbers[i]*2
}
console.log(fruits[i])
---------------------------
function square(num){
    return num * num
}
for(let i=0; i<n; i++){
    numbers[i]= square(numbers[i])
}
console.log(numbers) // [100, 400, 900]
steps:
//numbers[0] = 10 ->update 100 
//numbers[1] = 20 -> 400
//numbers[2] = 30 -> 900
//n=3 (array length)
//square: num => num* num
//i=0
//square(10) => 10*10 = 100
//i=1
//square(20) => 20*20 = 400

function go into callstack after comleting reomve from this.
----------------------------------------------------------------
# CLASS QUESTION
You are given a list of students
Make two separates lists
One list will have students with name that starts with a vowel.
another list will names starting with consonants.

let students = ["Aarav", "Bicky", "Thomas", "Aditya", "Ejaz", "Irfan", "Sandhya", "James"]
let vowel = []
let consonants = []
let vowelsArray = ["A", "E", "I", "O", "U"];
let n = students.length
for(let i=0; i<n; i++){
  let s= students[i]
  if(vowelsArray.includes(s[0])){
    vowel.push(s)  
  }else{
    consonant.push(s)
   }
}
console.log(vowel, consonants)
---------------
let name "java"
console.log(name,.toUpperCase())
---------------------------------------------
let vowelsArray = ["A", "E", "I", "O", "U"];

for (let i = 0; i < students.length; i++) {
  let name = students[i];
  if (vowelsArray.includes(name[0].toUpperCase())) {
    vowel.push(name);
  } else {
    consonants.push(name);
  }
}
-----------------------------------------------------------------------------------------
Objects: have different data types but key always string
let student ={
   "name": "Bicky",
   "rollNo":100
   "isPresent":true 
}
let arr = [1,2,3]
console.log(arr[2])
console.log(students[name])
console.log(student)
//create object -> firstName, lastName
let person ={
    firstName: "Pragya",
    lastName:"Sinha",
    age: 29,
    key: "Key"
}
let key="age"
console.log(person[key])//Key  pribt using bracket notation
console.log(person["key"])//Key

console.log(person["firstName"]+ " "+ person["lastName"])

//dot notation- don't take variables
console.log(person.key)/
console.log("Students with names starting with vowels:", vowel);
console.log("Students with names starting with consonants:", consonants);
---------------------------------------------------------------------------
JSON is also a javscript object
//Array of objects
let employees =[
    {empId:1, name:"James", salary:60000,country:"india"},
    {empId:1, name:"Shlok", salary:60000,country:"india"},
    {empId:1, name:"Vaani", salary:40000,country:"india"},
]
------------------------------------------------------------------
javascript does not hava stack , queue dtaa structure it has list
//includes-
console.log(fruits.includes("kiwi"))//false
---------------------------------------------------
function isAphaNumeric(str){
  str = str.toLowerCase()
  let charFlag = false
  let numFlag = false
  for(let i=0; i<str.length; i++){
     if(st[i] >=0 && str[i] <=9){
        numFlag=true
     }
     if(str[i] >="a" && str[i] <= "z"){
        charFlag =true
     }
  }
  return charFlag && numFlag
}
console.log(isAlphaNumeric("123ABC")) //true
console.log(isAlphaNumeric("123456")) //false
console.log(isAlphaNumeric("abcdef")) //false
-------next class--------------------------------------------
Solving problem in JS
Array of Object
HOF -> Map, Filter, ForEach, Reduce
*****************************************************************************************************
let a = 10 + "20";
console.log(a); //1020

// 10 (number) + "20" (string) → 
// JS converts number to string when + is used.
// So "10" + "20" → "1020" (string).
-------------------------------------------------------
console.log("5" * 2 + "1"); //101

// "5" * 2 → here * forces numeric conversion. "5" → 5.
// So 5 * 2 = 10.
// Now 10 + "1" → 10 (number) gets converted to string because + with string → "10" + "1" = "101"
----------------------------------------------------------------------------------------------------
console.log("10" - "7" + 3); //6

In JavaScript, both - (subtraction) and + (addition) are
left-to-right associative operators with the same precedence.
So the expression is evaluated from left to right.
// "10" - "7" → both strings are converted to numbers when - is used.
// So 10 - 7 = 3.
// Now 3 + 3 = 6 (both numbers, so normal addition).
-----------------------------------------------------------------------------------------
console.log( null == undefined, null === undefined ); // true false

// 👉 == → loose equality, allows type coercion. In JS, null == undefined is true.
// 👉 === → strict equality, no type coercion. null and undefined are different types.
// So result: true false
// Output: true false
------------------------------------------------------------------------------------------
console.log( [] + 1, [1] + 1 ); //1 11

// [] + 1 → empty array [] is converted to an empty string "" when used with +.
// So "" + 1 = "1".
// [1] + 1 → [1] converts to string "1".
// So "1" + 1 = "11".
// Output: "1" "11"
-------------------------------------------------------------------------------------------------
let x; 
console.log(typeof x, typeof y); //undefined undefined

// let x; means x is declared but not initialized, so value = undefined.
// typeof x → undefined.
// y is not declared at all. Normally referencing undeclared variables throws ReferenceError, 
but typeof y is special — it does not throw error, instead it returns undefined.

-------------------------------------------------------------------------------------------------------------------------------------
js_basics_90min.js

'use strict';
const user = { name: "Bicky", age: "29", active: "true", scores: ["10", "20", 30], meta: null };
const A = "10", B = 10, C = "42", D = 0, E = undefined, F = null, G = NaN;
const obj = { "key-1": 1, nested: { x: "2", y: 3 }, "weird prop": "ok" };
------------------------------------------------------
// B1
const isFortyTwoString = C==="42"
console.log(isFortyTwoString); // true
-----------------------------------------------------
// B2
const sumAB= Number(A) + B
console.log(sumAB); // 20
------------------------------------------------------
// B3
const concatAB= A+B*2
console.log(concatAB) // 1020
--------------------------------------------------------
// B4
const nestedSum = Number(obj.nested.x) +obj.nested.y
console.log(nestedSum)// 3+2= 5
-------------------------------------------------------
B5 (5 marks). Safe numbers & booleans. From user, create ageNum as a number, and activeBool as a boolean (non-empty string → true).
const ageNum= Number(user.age)    // "29" → 29
const activeBool= Boolean(user.active) // "true" -> true
console.log(ageNum)
console.log(activeBool)
-----------------------------------------------------------
Q6 (5 marks). Prevent accidental concatenation (alt coercion).
Create safeTotal that adds A and B to get 20 but without using Number(A). Use a different explicit coercion method.

const safeTotal = Numner(A)+B // +A converts "10" → 10
console.log(safeTotal)
---------------------------------------------------------

Q7 (4 marks). Equality snapshots. Create variables:
p1Loose, p1Strict for 10 vs "10"
p2Loose, p2Strict for null vs undefined Log them in one line.

const p1Loose = (10 == "10");      // true
const p1Strict = (10 === "10");    // false

const p2Loose = (null == undefined);   // true
const p2Strict = (null === undefined); // false

console.log(p1Loose, p1Strict, p2Loose, p2Strict);

console.log('DONE');




// === in JS is strict equality:
// Checks both type and value.
// "42" (string) is not equal to 42 (number).
// "42 " (extra space) is not equal either.
// Only when the input is exactly the string "42", it returns true.

// console.log('DONE');

***************************************************************************************
//Control flow:
if-else:

let rice = "perfect"
if(rice === "perfect"{
 console.log("Eat the biryani")
}else if(){
 console.log("Cook for some more time")
}else{
 console.log(""Ordre from Zomato")
}
if(true){
 console.log("Hello")
}else if(true){
   console.log("Hi")
}//whenever first time condition is true then it will ignore the remaining condition
whichever condition has higher piority it should be given first like
if there are two different if then it will run both.
---------------------------------------------------------------------------------------
//Switch Case:
switch(expression){
    case value1:
    case value2:
    case value3:
}
let day="Tuesday"
switch(day){
    case "Monday":
        console.log("Today is Monday")
    case "Tuesday":
        console.log("Today is Monday")
    default:
        console.log("None of the above")
}

---------------------------------------------------------------
Loops:
for (initialization; condition;increment/decrement){
}
for (let i=0;true;){
//this will run for infinity
}
for (let i=0;i<5; i=i+1){ 
//it will go infinite loop if i not give increment/decrement
   console.log(i)
}//0 1 2 3 4  ( vertically)
------------
let i=0;
while(i<=5){
 console.log(i)
 i++
}
----------------
let i=0
do{
 console.log(i)
 i++
}while(i > 5)
//run the code first
//then checks for condition
------------------------------------------------
//initioalization -> Starting point let i=0
check for condition
if true runs the code
increment/decrement
if false
then stop
------------------------
break/continue keyword
it will skip this
let eaten = 0
for(let plate=1; plate<=10; plate++){
  if(plate == 3){
      continue
  }
if(eaten >= 5){
  break
}
  console.log("Eatong Plate", plate)
  eaten++
}
-----------------------------------------------
function:
functionName(parameters){
 //code
}
functionName(arguments)

function add(a,b){
 let sum =a+b
 return sum
}
console.log(add(5, 10))
console.log(add(25, 100))
console.log(add(50, 210))
---------------------
function greet(){
  console.log("Hello")
  return "Hi"
}
console.log(greet()) //undefined

Parameter: passed during function declaration
argument:- passed during function calling

//Undefined is data type
function greet(){
  console.log("Hello")
  return "Hi"
}
console.log(greet())
--------------------------------------------------------------------
Javascript runs in 2 phase- Memory allocation phase Execution phase
what is hoisting in js?
console.log(x) //undefined
var x=20  //var default value in memory allocation
console.log(x)
let a=10
const b=5

add(2,3)  //skip in memory allocation

console.log(a)//5  //skip in memory allcation
function add(a,b=0){
console.log(a,b) //2 3
let sum =a+b
return sum
memory : x=undefined, a, b  add: function(a,b){....}
20 
2 3
5
10

function expression
const add = (a,b=0)=> a+b
add(2,3)
  //logic
  return

//function declaration function expression

**************************************************************************************************************
function printTable(num){
  for (i=1;i<=10;i++){
  // console.log(num +" x " +i +" = "+ num*i)
  //using backticks to build string directly with placeholders ${},
  // instead of concatination(+) or commas(,), This is the modern ES6+ standard way.
   console.log(`${num} x ${i} = ${num * i}`)
  }
}
printTable(5)
// In string concatination(+), all parts are combined into one single string value,
// before being sent to console.log.
//
// In contrast, when you use commas(,) 
// console.log just takes multiple argumnets.
// it doesn't join them into one string, it prints each with a space in between.
// Performance-wise:
// If you care about micro-speed → use commas are slightly faster,
// If you care about readable output → use +.

------Using string length-----------------------------------
function countDigits(num) {
  const newNum = num.toString()
  return newNum.length
}
console.log(countDigits(987654)); // 6
---Using while loop-----------------------
function countdigits(num){
  count=0
  while ((num -(num%10))/10){
    count++
  }
}
console.log(countDigits(1234))
--------------------------------------------
function reverseString(str) {
  let reversed = "";
  for (let i = str.length - 1; i >= 0; i--) {
    reversed += str[i];
  }
  return reversed;
}
----------------------------------------------
function reverseString(str) {
  return str.split("").reverse().join("");
}
console.log(reverseString("hello"))
-------------------------------------------------------------------------
let list = [1,3,1,5,3,6,7,7,3]
let obj = {}
for (let el of list){
  if(obj[e1] == undefined ){
    obj[e1] = 1
  }else{
      obj[e1] += 1
  }
  //obj[e1] = (obj[e1] || 0) +1
}
console.log(obj)
-----------------------------------------------------------
//Group of Users: Group the users based on their city.
let users = [
   {userName: "Naresh", city: "Vizag"},
   {userName: "Smith", city: "Nagpur"},
   {userName: "Aashish", city: "Uttarakhand"},
   {userName: "Bicky", city: "BLR"},
   {userName: "User 1", city: "BLR"},
   {userName: "User 2", city: "Uttarakhand"},
   {userName: "User 3", city: "Vizag"},
   {userName: "User 4", city: "Nagpur"},
   {userName: "User 5", city: "Nagpur"},
   {userName: "Priyanshu", city: "Moradabad"},
]
//output:
//{"vizag": ["Naresh", "User 3], "BLR": ["Bicky", "User 1] , ....}

function groupUsers(data, key){
   let ans = {}
   for (let user of data){
     if(ans[user[key]] == undefined){
      ans[user[key]] = 0
     }
     //ans[user[key]]++
     ans[user[key]].push(user.userName)
   }
   //return ans
}
console.log(groupUsers(users, "city"))
console.log(ans
//step1 - ans ={vizag: ["Naresh", Nagpur: ["Smith"]}  , key: "city"
user = {userName: "Smith", city: "Nagpur"}
-----------------------------------------------------------------------------------
//Cart(ecommerce): Final Amount to be paid After Discount
//logic : {name: "Maggi", price: 12, qty: 3}
//discount will be given if cart value is greater than or equal to 500rs.Discount will be 10% of the cart value 
//after discount 3 things will be added.
Platform fee: 10rs
Tax: 5% will be added
//Delivery Charge: 20rs (will not beadded if total amount after discount is greater or equal to 500rs)
let cart = [
    {name: "Maggi", price: 12, qty: 3},
    {name: "Fortune", price: 12, qty: 3},
    {name: "Maggi", price: 12, qty: 1},
    {name: "Flour", price: 12, qty: 1},
    {name: "Sugar", price: 25, qty: 1},
    {name: "Salt", price: 25, qty: 1},
    {name: "Tata tea", price: 200, qty: 1},
    {name: "Milk", price: 70, qty: 1},
]
function totalAmount(data, tax=5, discountRate=10, discountAmount=500, 
    platformFee=10, deliveryChargeWaiveOffAmount=500){
  let initialTotal = 0;
  for(let item of data){
    initialTotal += item.price*item.qty
  }
  let discountedTotal = initialTotal
  if(initialAmount >= discountAmount ){
      discountedTotal -= discountedTotal*discountRate/100
  }
   let taxedTotal = discountedTotal*(100+tax)/100
   let total = taxedTotal+platformFee
   if(discountedTotal < 500){
     total += deliveryCharge
   }
  console.log(initialTotal)
} //595.9
----------------------------------------------------------------------------------------


-------------------------------------------------------------------------------------------------------
//Filtering or merging similar/duplicate data.  Brute force
let cart = [
    {name: "Maggi", price: 12},
    {name: "Maggi", price: 12},
    {name: "Maggi", price: 12},
    {name: "Fortune Oil", price: 99},
    {name: "Potato", price: 40},
    {name: "Flour", price: 60},
    {name: "Sugar", price: 50},
    {name: "Salt", price: 25},
    {name: "Tata Tea", price: 200},
    {name: "Milk", price: 70}
]
//obj = {maggi: 3}
let ans = {}
let prices = {}
for(let item of cart){
  if(ans[item["name"]] == undefined){
      ans[item["name"]] =1
  }else{
      ans[item["name"]]++
  }
   prices[item["name"]] = item.price
}
//console.log(ans, prices)
-----------------------
Output like this:
{
  Maggi: 3,
  'Fortune Oil': 1,  
   ....
} {
  Maggi: 12,
  'Fortune Oil': 99,
   .....
}
------if add this------------------
let arr = []
for (let key in ans){
  let obj = {name: key, price:prices[key], qty: ans[key]}
  arr.push(obj)
}
console.log(arr)
---------output like-----------------------------
[
  { name: 'Maggi', price: 12, qty: 3 },
  { name: 'Fortune Oil', price: 99, qty: 1 },
   ....
]
------------------------------------------------------------------
let user = [
  {userId: 1, userName: "User 1", createdAt: 100},
  {userId: 1, userName: "User 1", createdAt: 100},
  {userId: 1, userName: "User 1", createdAt: 100},
  {userId: 1, userName: "User 1", createdAt: 100},
]


--------------------------------------------------------------------------------
//Logic: remove the ones with with same userID. keep only ones that have higher createdAt value.
let userCreatedAt = {}
let userNames = {}
for(let user of users){
   console.log(user)
  if(userCreatedAt[user[userId]] == undefined){
     userCreatedAt[user[userId]] = user[creaedAt]

  }else{
     userCreatedAt[user["userId"]] = Math.max
        (userCreatedAt[user["userId"]], user["createdAt"])
  }
   userNames[user["userId"]] = user.userName
}
console.log(usercreatedAt)
let arr = []
for (let key in userCreatedAt){
  let obj = {userId: key, userName: userNames[key], createdAt: userCreatedAt[key]}
  arr.push(obj)
}
console.log(arr)

******************************************************************************************

Async: Programming concept used to run tasks without blocking main program flow

//Trying to get Data from the internet

//Write to code to fetch the data

//call tis code

//it will go to the url

//and then try to get the data

//return some data
-----------------------------------------------------------------------
console.log(1) //synchronous code
for (let i=0;i<100000000000000000; i++){  //this blocking operation until for lopp ends 
}
console.log(2)//synchronous code
-----------------------------------------------------------
asynchronous code using asyncronous function setTimeout(): non-blockng operation
setTimeout(callback,1000) //1000ms =1 sec of delay ,//Asynchronous code: non-blocking piece of code
setTimeout(()=>console.log(2),1000) //did not block lower code so async
console.log(2)
---------------------------------------------
call satck: console.log(3)
callback queue: ()=>()console.log(2)},
---------------------------------------------------------------
JS- single threaded language(can't do multiple thing at once)
Event Loop?
Using Call Stack   // synchronous: An function call go to go stack
WebAPIs/ callback queue  //Asynchronous go queue Promises, setTimeout, setInterval, async await,fetch

Macro task queue -> lower priority
  (SetTimeout)
Micro task queue -> higher priority
  (Promise)

Promises syntax:
Promise.resolve().then(()=> console.log(5)) //go to callback queue 

console.log(1)
setTimeout(()=> console.log(2), 500 ) //1000ms =1 sec of delay ,//Asynchronous code: non-blocking piece of code
console.log(3)
Promise.resolve().then(()=>console.log(2) ) //did not block lower code so async

1
3
4
2
-------------------
console.log(1)
setTimeout( ()=> {
     console.log(2)
     Promise.rsolve()
       .then(console.log("Inside SetTimeout >Promise))
  }
)
Promise.resolve()
  .then( ()=> {
       console.log(4)
       setTimeout( ()=> console.out("inside Promise > setTimeout"))
})
console.log(3)
----------------------------------
console.log(1) //go to call stack
setTimeout( ()=> { //entire macro queue
     console.log(2)
     Promise.rsolve()
       .then(console.log("Inside SetTimeout >Promise"))
  }
)
Promise.resolve() //mico
  .then( ()=> {
       console.log(4)
       setTimeout( ()=> console.out("inside Promise > setTimeout"))
})
console.log(3)

//call stack:
    micro : 1.console.log(1), 3.Promises  //first priority
    macro: 2.setTimeout()    setTimeout()2
    
1
3
4
2
Inside SetTimeout >Promise   
inside Promise > setTimeout
-------------------------------------------------

console.log("start") //1st go call satck
Promise.resolve()  //2 entire function Promise go to micro queue
  .then( ()=>{
     Promise.resolve().then( ()=> 
          console.log("1"))
     console.log("2")
})

setTimeout( ()=>{   //3 settimeout
  Promise.resolve().then(()=>{
    console.log("3")
  })
   console.log("4")
})
console.log("end")

call satck: 1.c
micro queue : Promise1  4.promise2 promise3
macro queue : settimeout1
//cosnosle.log()

remove c then promise1 then promise2
start
end
2
1
4
3

--------------------
//callback function? boo function passed as a parameter
function fun(boo){
   boo()
   console.log("start")
   setTimeout(boo,2000)
}
fun(boo)
function boo(){
  console.log("hi")
}
output:
start
hi
---------------
function getData(callback){
   setTimeout( ()=>{
     callback("Data Received")
   },2000)
}
getData((data1)=>{ 100more lines can be that is why Promise came
   getData((data2)=>{
      getData((data3)=>{
         console.log)data1,data2,data3)
      }
   }
  console.log(msg)
})
This is callback hell/callback pyramid so use Promises
--------------------------------------------------------
Promises in js are object that takes 3 types of value: success,fail,pending
Primise.resolve()
 .then((data)=>{
    let ans data.map=>{}
    return ans
})
.then((data)=>{

})
.catch((err)=>{
   console.log(err.message)
})
.finally(()=>{

})

----------------------------------------------------------
let i =-
let id=setInterval(()=>{
   if(i==5){
     clearInterval()
   }
},1000)

































