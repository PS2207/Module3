Q1: Which of the following best expresses the difference between data and information?
(a) Data are meaningful facts whereas information is unprocessed symbols. (b) Data are raw facts,whereas information is processed and meaningful.✔️
(c) Data are always numbers,whereas information is always text.           (d) Data and information are interchangeable terms.

Q2: In the relational model, which element uniquely identifies each row in a table?
(a) Foreign key  (b) Alternate key  (c) Primary key✔️   (d) Candidate key

Q3: Which level of database abstraction describes how the data are actually stored on disk(indexes, hashing)?
(a)External/View level  (b)Conceptual level (c)Physical/Internal level✔️ (d)Logical level

Q4: Which database model stores information as nodes, edges, and properties, making it especially suitable for relationship-heavy data(e.g social networks)?
(a)Hierarchical model  (b)Relational model  (c)Graph model ✔️ (d)Flat-file database

Q5: Which statement is true for a flat-file database but false for a DBMS?
(a)Data are stored in multiple related tables (b)Complex querying and transaction control are provided.
(c)Only one simple table with no inter-table relationships is used.✔️ (d)It enforces strong data integrity constrainst automatically.

Q6: Logical data independence means that changes mae at which level should not affect external views?
(a) Physical level (b)Conceptual(logical) schema  (c)Internal storage model (d)Application program level

Q7: In a network DBMS, what relationship strength makes it more flexible than the hierarchical model?
(a)Only one-to-one links (b)Fixed one-to-many links  (c)Many-to-many links through multiple owners/members records  (d)No explicit links(all data are flat)

Q8: The primary goal of data abstraction in a DBMS is to:
(a)Compress data for efficient storage (b)Hide complex storage details from users while presenting a simplified view 
(c)Encrypt for security (d)Remove redundant data from all tables

Q9: Which NoSQL database type stores data as self-describing documnets(often JSON-like) and is popular for its flexible schema?
(a)Graph database (b)Document database (c)Key-value store (d)Column-family store

Q10: Given the table definition below,which statement correctly adds a primary-key constraints on column Sno?
CREATE TABLE Employee(
   Sno Number,
   Fname Varchar2(50),
   Lname VARCHAR2(50),
   Age NUMBER,
   Salary Number,
   Branch NUMBER
);
(a)ALTER TABLE Employee ADD PRIMARYKEY(Sno); (b)ALTER TABLE Employee ADD CONSTRAINT pk_emp PRIMARY KEY(Sno);✔️
(c)ALTER TABLE Employee ADD UNIQUE(Sno) PRIMARY; (D)ALTER Employee TABLE ADD KEY Sno;
To add a Primary Key in an existing table

----------------------------------------------------GradedAssignment1-----------------------------------------------------------------------------------------------------------------------

(Q1)To generate a list of all employees and their managers,including the top-level employees who do not have a manager, which query is most suitable?
(a)SELECT E.EmpName, M.EmpName FROM Employees E INNER JOIN Employees M ON E.ManagerID = M.EmpID;
(b)SELECT E.EmpName, M.EmpName FROM Employees E LEFT JOIN  Employees M ON E.ManagerID = M.EmpID;
(c)SELECT E.EmpName, M.EmpName FROM Employees E RIGHT JOIN Employees M ON E.ManagerID = M.EmpID;
(d)SELECT E.EmpName, M.EmpName FROM Employees E, Employees M WHERE E.ManagerID = M.EmpID;

(Q2)You need to find all departments that have no employees assigned to them.Which of the following is the most effective approach?
(a)SELECT d.dept_name FROM departments d INNER JOIN employees e ON d.dept_id=e.dept_id WHERE e.emp_id IS NULL;
(b)SELECT d.dept_name FROM departments d LEFT JOIN employees e ON d.dept_id=e.dept_id WHERE e.emp_id IS NULL;
(c)SELECT d.dept_name FROM departments d WHERE dept_id NOT IN(SELECT e.dept_id FROM employees e WHERE dept_id IS NOT NULL);
(d)Both (b) and (c) are effective approaches.

(Q3)What is the result of joining a table to itself using different aliases?
(a)A Syntax error  (b)A Cartesian Product  
(c)A Self Join,used for querying hierarchical data  (d)A Full Outer Join

(Q4)You have two tables,FullTimeEmployees and Contractors.To get a single list of all unique people who work for the company,regardless of their employemnt type,which operator should you use?
(a)UNIONALL  (b)INTERSECT  (C)UNION  (d)FULLOUTERJOIN

(Q5)Which set operator is functionally equivalent to a LEFTJOIN where the WHERE clause filters for NULL on the right table's key?
(a)UNION  (b)INTERSECT   (c)EXCEPT(MINUS)  (d)UNIONALL

(Q6)What is a key difference between UNION and UNIONALL?
(a)UNIONALL is faster beacuse it does not remove duplicate rows.
(b)UNION keeps duplicate rows, while UNIONALL removes them.
(c)They are functionally identical, but UNIONALL is the SQL standard.
(d)UNION requires the columns to have the same names, while UNIONALL does not.

(Q7)In which order are the following SQL clauses evaluated?
(a)SELECT,FROM,WHERE,GROUP BY,HAVING   (b)FROM,WHERE,GROUP BY,HAVING,SELECT
(c)FROM,GROUP BY,HAVING,WHERE,SELECT   (d)SELECT,WHERE,FROM,HAVING,GROUP BY

(Q8)To find all individuals who are listed as both a FullTimeEmployee and a Contractor, which operator is most direct?
(a)UNION  (b)EXCEPT (c)INTERSECT✔️  (d)MINUSALL
UNION: returns all distinct rows from both sets & removes duplicate entries.
EXCEPT: returns from the first set that are not in the second.
INTERSECT: returns only the rows that are present in both result sets.
MINUSALL: This is not a standard SQL operator.

(Q9)You want to find departments where the average salary is above $65,000.which query is correct?
(a)SELECT DeptName FROM Departments JOIN Eployees ON... WHERE AVG(Salary)>65000;
(b)SELECT DeptName FROM Departments JOIN Employees ON... GROUP BY DeptName HAVING AVG(Salary)>65000;
(c)SELECT DeptName FROM Departments JOIN Employees ON...GROUP BY DeptName WHERE AVG(Salary)>65000
(d)SELECT DeptName,AVG(Salary) FROM Departments...WHERE AVG(Salary)>65000;

(Q10)What is the purpose of the HAVING clause?
(a)To filter before they are grouped.  (b)To filter groups based on the result of an aggregate function.
(c)To substitute the WHERE clause when using joins.  (d)To order the results of a grouped query.

(Q11)What is the primary advantage of a window function over a standard aggregate function?
(a)They are faster(❌Performance depends on context)
(b)They can perform calculations across a set of rows without collapsing them into a single.
(c)They can be used in the WHERE clause(❌Window functions can not be directly used in the WHERE clause.)
(d)They only work on numeric data(❌They can work with dates, strings etc, not just numbers)
Window functions like- RANK()
EX-SELECT emp_id,department,salary,
  RANK() OVER (PARTITION BY department ORDER BY salary DESC) AS rank_in_dept
FROM employees;
THis works without grouping or collapsing multiple rows into one.
Aggregate Function like AVG(), SUM(), COUNT()

(Q12)In the windows function RANK() OVER (PARTITION BY DeptID ORDER BY Salary DESC), what does PARTTION BY DeptID do?
(a)It filters the data to only one department
(b)It sorts the employee by their department ID
(c)It restarts the ranking calculation for each new department.
(d)It groups the rows into a single output row per departemnt.

(Q13)If two employees have the same salary,what is a key difference between RANK() and DENSERANK()?
(a)RANK() will assign them the same rank and skip the next rank(s); DENSERANK() will not skip
(b)DENSERANK() will assign them ranks based on EmpID.✔️
(c)RANK() cannot handle ties.
(d)DENSERANK() is faster but less accurate.

(Q14)Which function would you use to find the salary of the employee in the row immediately preceding the currect row , within the same department?
(a)RANK()  
(b)LEAD(salary,1)  (returns salary from the next row,not the previous one )
(c)LAG(Salary,1)✔️  (returns the salary of the previous row)For mysql before version8, this won't work.
(d)ROWNUMBER() (Just gives a unique row number in order)
LAG(column,offset) is a window function that lets you access data from previous row within the same result set without using a self-join.

(Q15)The query SELECT DeptID, COUNT(EmpID) FROM Employees GROUP BY DeptID; will return:
(a)The total number of employees.
(b)A list of employees in each department. Group rows based on department.Counts how many employees exist in each department
(c)The number of employees in each department.
(d)An error beacuse COUNT(*) should be used.

(Q16)What is a Common Table Expression(CTE)?
(a)A permanent table used for storing temporary results.
(b)A type of subquery that can only be used in the WHERE clause.
(c)A temporary,named result set,defined using the WITH clause,to simplify complex queries.
(d)A special type of view that is automatically dropped.
A CTE (Common Table Expression) is:
A temporary result set.
Defined using the WITH clause.
Exists only during the execution of a single SQL statement.
Makes complex queries easier to read and write, especially when dealing with joins, recursion, or repeated subqueries.
WITH DeptCounts AS (
    SELECT DeptID, COUNT(EmpID) AS EmpCount
    FROM Employees
    GROUP BY DeptID
)
SELECT *
FROM DeptCounts
WHERE EmpCount > 5;

(Q17)To find all employees who earn more than the company's average salary,which is the most common approach?
(a)Using a LEFTJOIN (b)Using a scalar subquery in the WHERE clause
(c)Using the HAVING clause  (d)Using a window function.

(Q18)Which feature is unique to CTEs compared to standard subqueries?
(a)They can be referenced multiple times within the same query.
(b)They can be used to write recursive queries.
(c)They improve query readability by breaking down logoc.
(d)All of the above.

(Q19)Which statement is true about the DELETE statement?
(a)DELETE FROM employees; removes the table structure.
(b)DELETE is a DDL command.
(c)A WHERE clause is mandatory.
(d)DELETE FROM Employees; remove all rows from the table but the table itself remains.

(Q20)The CASE statement in a SELECT clause is used for what purpose?
(a)To filter rows like a WHERE clause.
(b)To perform conditional(if-then-else) logic to return a value
(c)To join tables based on  a condition.
(d)To sort results based on multiple columns.

(Q21)What is a correlated subquery?
(a)A subquery that is executed only once before the outer query.
(b)A subquery that uses values from the outer query, causing it to be re-evaluated for each row of the outer query.
(c)A subquery that must return multple columns
(d)Another name for a Common Table Expression(CTE)

(Q22)You want to find all employees who work in a department located in 'New York'. Which query using a subquery is structured correctly?
(a)SELECT EmpName FROM Employees WHERE Location='NewYork';
(b)SELECT EmpName FROM Employees WHERE DeptId IN(SELECT DeptId FROM Departments WHERE Location='New York');
(c)SELECT EmpName FROM Employees WHERE(SELECT Location FROM Departments)='NewYork;
(d)SELECT EmpName FROM Employees E JOIN Departments D ON E.DeptID=D.DeptID;

(Q23)A subquery placed in the FROM clause of a SELECT statement is also known as:
(a)A scalar subquer
(b)A correlated subquery
(c)A derived table or inline view
(d)A window function

(Q24)Which of the following is a key rule for using set operators like UNION or INTERSECT?
(a)The tables must have the same name.
(b)The queries must select the same number of columns with compatible data types.✔️
(c)An ORDER BY clause can be used in each SELECT statement.
(d)They can only be used on two tables at a time.
UNION removes duplicate entire rows, not just duplicate values in one column, 
here ids are same, but other columns name,course_name are different
so it will not remove.
Although IDs are the same, the entire rows are different, so they are not dupicate to SQL. 
UNION checks all columns in the row for duplication, not just one row.
TABLE1: students_2024        TABLE2: student_2025
id  name                     id   course_name
1   Alice                    1    English
2   Bob                      2    Math
SELECT id,name FROM student_2024
UNION
SELECT id,course_name FROM student_2024
OUTPUT: TABLE3
id  name             
1   Alice                
2   Bob              
1   English                 
2   Math     
but if i want output like this
OUTPUT: TABLE3
id  value     type             
1   Alice     Name                
2   Bob       Name   
1   English   Subject name             
2   Math      Subject name
Use this query-
SELECT id, name AS value, 'Student Name' AS type  FROM student_2024
UNION
SELECT id, course_name AS value, 'Subject Name' AS type  FROM student_2025;

(Q25)A TRUNCATE TABLE statement is different from DELETE FROM table because:
(a)TRUNCATE is a DML operation and is slower.
(b)TRUNCATE is a DDL operation, cannot be easily rolled back,and resets identity columns
(c)TRUNCATE can be used with a WHERE clause
(d)DELETE removes the table,while TRUNCATE only removes the data.





-------------18-07-25-------------------------------------
CREATE TABLE employees(emp_id INT PRIMARY KEY, emp_name VARCHAR(50), dept_id INT, dept_name VARCHAR(100));
/*
INSERT INTO employees(id , name, department, salary, age)
Values
(1,  'Alice',  'HR',        40000,     25),
(2,  'Bob',    'IT',        60000,     30),
(3,  'Jenny',  'HR',        34500,     28),
(4,  'john',   'IT',        75000,     35),
(5,  'Alex',   'FINANCE',   50000,     40);
*/
/*
INSERT INTO employees(emp_id , emp_name, dept_id, dept_name)
Values
(1,  'Alice',  101, 'Sales'),
(2,  'Bob',    102, 'Engineering'),
(3,  'Rahul',  103, 'HR'),
(4,  'Megha',   104, 'Electrical');
*/
/*
SELECT * FROM employees
 --WHERE (SELECT dept_id FROM employees WHERE dept_name='Sales'); /*single row inner*/
 WHERE dept_id= (SELECT dept_id FROM employees WHERE dept_name='Sales');
*/
/*
INSERT INTO employees(emp_id , emp_name, dept_id, dept_name)
Values(1,  'RR',  107, 'Sales');
*/
/*
UPDATE employees
SET dept_id
*/

CREATE TABLE employee (emp_id INT PRIMARY key, emp_name VARCHAR(100), dept_id VARCHAR(100);
--CREATE TABLE department  (dept_id INT PRIMARY key, dept_name VARCHAR(100), dept_id VRCHAR(100);
--INSERT into employee (emp_id,emp_name,dept_id) VALUES(1,'Alice' ,101);


-------breakout-----------

/*
CREATE TABLE employee (emp_id INT PRIMARY key, emp_name VARCHAR(100), dept_id VARCHAR(100);
--CREATE TABLE department  (dept_id INT PRIMARY key, dept_name VARCHAR(100), dept_location VRCHAR(100);
--INSERT into employee (emp_id,emp_name,dept_id) VALUES(1,'Alice' ,101);

INSERT INTO department VALUES(10, 'HR', 'uk'), (11, 'sales', 'usa'),(12, 'engineer', 'india');
                       
SELECT emp_name FROM employee WHERE dept_id IN(
     SELECT dept_id FROM department WHERE dept_location='uk';
    );
 */                      
 CREATE TABLE employee (emp_id INT PRIMARY key, NAME VARCHAR(100), department VARCHAR(100),salary, manager_id INT PRIMARY KEY);
CREATE TABLE employee (emp_id INT PRIMARY key, emp_name VARCHAR(100), dept_id VARCHAR(100);
 --sub query in corretalted -find employees who earn more than average of their department                  
 SELECT NAME, department,salary FROM employees e1 WHERE salary >(SELECT AVG(salary) FROM employees e2 WHERE e1.department=e2.department);                      
    
 Find employees who earn more than their manager?JOIN
 List employees with second highest salary? 
  SELECT * FROM employees ORDER by salary  DESC  offset 1 limit 1;                     
  SELECT NAME, salary  FROM employees WHERE salary =(SELECT salary FROM employees WHERE salary < (SELECT MAX(salary) FROM employees );;                       
                       
                       
                       
                       
                       
 --sub query in SELECT clause add extra column of average salary of their department
   --Suubquery in from clause find depatrment with max avg salary                    
SELECT  department,avg_salary 
FROM (SELECT department , AVG(salary) AS avg_salary 
      FROM employees  
      GROUP BY department
 ) AS dept_avg; 
    --OR ORDER BY avg_salary DESC LIMIT 1;
 WHERE  avg_salary =(
   SELECT MAX(avg_salary) 
   FROM (SELECT department, AVG(salary) AS avg_salary FROM employees GROUP BY department )AS inner_avg);  
 -------------------------------------------------------                      
 SELECT NAME, department  
 FROM employees
 WHERE department IN(
   SELECT department
   FROM employees
   GROUP BY department
   HAVING AVG(salary) > 55000
   );
   --Subquery with ANY/All - Employees earning more than ANY person in HR   
   SELECT NAME, salary from employees                    
   WHERE salary > ANY (SELECT salary FROM employees WHERE department='HR');                    
------------------------------------------------------------------------------------                       
What are set operation?
when we needed set operation?
types of set operation?

SET Operation
SELECT column1,column2 FROM table1
UNION
SELECT column1,column2 FROM table2;

Table A:Employees_US      Table B:Employees_UK         Name
Emp_id   Name             Emp_id   Name                Alice
1        Alice            2        Bob                 Bob
2        Bob              4        Diana               Charlie
3        Charlie          5        Evan                Diana
                                                       Evan

SELECT Name FROM Employees_US
UNION ALL
SELECT Name FROM Employees_UK
Name
Alice
Bob
Charlie
Bob
Diana
Evan


Table A:Sales_Dept      Table B:HR_Dept            emp_name  
Emp_id   emp_name       Emp_id    emp_name         Raj
101      Raj            201       Priya            Meena
102      Meena          202       Raj              Alok
103      Alok           203       Nitin            Priya
                                                   Nitin

wrong query for that output-
SELECT emp_name FROM Sales_Dept WHERE emp_id <105
UNION ALL
SELECT emp_name FROM HR_Dept  WHERE emp_id < 105;

right query
SELECT emp_name FROM Sales_Dept AS name 
UNION 
SELECT emp_name FROM HR_Dept AS name;

SELECT emp_name FROM Sales_Dept
UNION 
SELECT emp_name FROM HR_Dept 
ORDER BY emp_name;
---------------------------------------
East_Sales           West_Sales
emp      sales       emp  sales
A        1000       
B        1200

How many rows will this query return? 4
Employees Contractors
emp_id  emp_name     emp_id  emp_name      
1       Ravi         101     Sneha   
2       Sneha        102     Kiran
3       Asha
SELECT emp_name FROM employees
UNION
SELECT emp_id, emp_name FROM contractors;

Will this query execute? no
SELECT emp_id, emp_name FROM employees
UNION
SELECT emp_name FROM contractors;

SELECT emp_id, emp_name FROM employees
UNION
SELECT emp_name,emp_id FROM contractors; column data type mismatch  int,varchar & varchar,int order
-----------------------------------------------------------------------------------------------------
if both tables  are empty? nothin return
SELECT  emp_name FROM employees
UNION
SELECT emp_name FROM contractors;

difference between these 2 queries-
SELECT column_name FROM table1 ORDER BY column_name    error
UNION
SELECT column_name FROM table2;

SELECT column_name FROM table1 
UNION
SELECT column_name FROM table2
ORDER BY column_name;
if Raj's emp_id is different in both tables,
UNION will treat them as 2 distinct rows & will not remove either as a duplicate.
--------------------------------------------------------
What is INTERSECT query?
SELECT name,dept FROM Employees
INTERSECT
SELECT name,dept FROM Employees;
name dept
Bob  Finance
-------------
SELECT name,dept FROM Employees
INTERSECT ALL
SELECT name,dept FROM Employees;
name     dept       name    dept
Alice    HR         Bob     Finance
Bob      Finance    Diana   Sales
Charlie  IT         Eva     HR
Diana    IT

name dept
Bob  Finance
----------------------------------------
What if one column is of different data type? Error due to data type
Use INTERSECT to find employees who are also managers and work in same department?
----------------------------------------------------------------------------------------- 
INTERSECT VS INNER JOIN
SELECT emp_id name
ON EmpID=EmpID2
---------------------------------
What is EXCEPT in SQL?
SELECT col1,col2,...
FROM table1
EXCEPT
SELECT col1,col2,...
FROM table2;

SELECT student_id, name FROM Students_2024
WHERE student_id NOT IN (SELECT student_id FROM Students_2025);


SELECT name,student_id FROM Students_2024
EXCEPT
SELECT student_id,name FROM Students_2025;

(Q)What will be the result for this?  nothin return subtracting same row
SELECT student_id FROM Students_2024
EXCEPT
SELECT student_id FROM Students_2024; takes all columns only , takes one column so column mismatch
SELECT 8 FROM Students_2024
EXCEPT
SELECT name FROM Students_2025;
How to find records in Table A but not in Table B or C? EXCEPT, UNION bth use
SELECT * FROM A
EXCEPT
SELECT * FROM B
EXCEPT
SELECT * FROM C
-----------------------
ADVANCED SQL SET OPERATION
(SELECT student_id FROM courses_2023
UNION
SELECT student_id FROM courses_2024)
EXCEPT
(SELECT student_id FROM courses_2023
INTERSECT
SELECT student_id FROM courses_2024);
------------
SELECT Course FROM courses_2023
INTERSECT
SELECT Course FROM courses_2024


------------------------------------------
FOREIGN KEY is used to references the PRIMARY KEY OF another table.
TBALE1:DEPARTMENT  TABLE2:EMPLOYEE
dept_id  dept_name     emp_id, emp_name, dept_id
CREATE TABLE department(dept_id INT PRIMARY KEY, dept_name VARCHAR(50)  );
CREATE TABLE employee(emp_id INT PRIMARY KEY, emp_name VARCHAR(50) , dept_id INT FOREIGN KEY(dept_id) REFERENCES department(dept_id) );
-----------------------------------------------------------------------
BEGIN TRANSACTION;

CREATE TABLE accounts(ID PRIMARY KEY , NAME VARCHAR(50), BALANCE FLOAT );
//What if error here
INSERT INTO accounts VALUES
(1,'ALICE'10000),
(2,'BOB',20000);

COMMIT;
-----------------------
BEGIN TRANSACTION;

UPDATE accounts
SET balance=balance-1000
WHERE ID=1;
//error
UPDATE accounts
SET balance=balance+1000
WHERE ID=2;

ROLLBACK;  //back to initial state
COMMIT: Save All Changes Permanently
----------------------------


SUPER KEY- ((st_id),(email),(phone), (st_id,email), (st_id,phone), (email,phone) , (st_id,email,phone))
CANDIDATE KEY- 
CREATE TABLE orders(ID INT PRIMARY KEY, customer_id REFERENCES customer(ID) );

INTEGRITY
MAINTAIN INTEGRITY-
ENTITY INTEGRITY - UNIQUELY IDENTIFY PRIMARY KEY
DOMAIN INTEGRITY-
REFERENCIAL INTEGRITY - FOREIGN KEY
//Entity Integrity

//Domain Integrity

//Referential Integrity
CREATE TABLE Enrollments(enroll_id INT PRIMARY KEY,st_id ,course_id VARCHAR(50), enroll_date DATE, );

ACID properties within TRANSACTION:
ATOMICITY- All successfull steps or if fail then Revert back transaction again
CONSISTENCY - A-1000 B- 1000
              A-500 B-1500   CONSISTENT TRANSACTION, OTHERWISE INCONSISTENCY TRANSACTION
ISOLATION- must not intefere two parallel transaction
DURABILITY- After commit -no chance to revert



---------------Assignment 28-0725------------------------------------------------------------------------------------------------
 Database Schema:
 • Customers– CustomerID INT PRIMARY KEY– Name VARCHAR(100)– City VARCHAR(50)
 • Orders– OrderID INT PRIMARY KEY– CustomerID INT REFERENCES Customers(CustomerID)– OrderDate DATE– Status VARCHAR(20)
                                    CustomerID INT FOREIGN KEY(customerID) REFERENCES Customers(CustomerID)
 • OrderItems– OrderID INT REFERENCES Orders(OrderID)– ProductID INT REFERENCES Products(ProductID)– Quantity INT
 • Products– ProductID INT PRIMARY KEY– ProductName VARCHAR(100)– Price DECIMAL(10,2)– StockQuantity INT
 1
Questions
 Q1. Write an SQL query to display all customers who do not have any orders yet.
 Q2. Suppose you want to change the status of all orders placed before ‘2023-01-01’ to ‘Archived’.
 Write the SQL statement to do this.
 Q3. Write an SQL statement to insert a new product called ’Wireless Mouse’ with a price of
 25.99 and stock quantity of 100.
 Q4. A customer named ’Alice Smith’ has made an order today. Write an INSERT query for
 the Orders table assuming her CustomerID is 5 and status is ‘Pending’.
 Q5. You discover some products have a stock quantity less than zero due to a bug. Write an
 UPDATE query to set any negative stock quantities to zero.
 Q6. Write an SQL query to delete all cancelled orders (Status = ’Cancelled’) that were placed
 in 2022.
 Q7. A customer moves to a new city. Write an UPDATE statement to change the city of the
 customer with CustomerID = 3 to ‘San Francisco’.
---------------------------------------------------------------------------------------------------
CustomerID    Name             City      OrderID  CustomerID OrderDate Status    OrderID  ProductID Quantity 
 4            Ramesh Kumar     Delhi      
 7            Meera Shah       Chennai 
---------------------------------------------------------------------------------------------------------------------------

Solution 1  :  SELECT c.* FROM Customers c LEFT JOIN Orders o ON  c.CustomerID = o.CustomerID  WHERE o.OrderID IS NULL ;
CustomerID    Name             City    
 4            Ramesh Kumar     Delhi      
 7            Meera Shah       Chennai 
----------------------------------------------------------------------------------------------------------------------------

Solution 2 : UPDATE orders SET Status = 'Archived'  WHERE OrderDate < '2023-01-01';
OrderID    CustomerID   OrderDate      Status   
 101            1       2022-12-30     Archived 
 102            2       2023-01-02     Pending  
--------------------------------------------------------------------------------------------------------------------------------

Solution 3 : INSERT INTO Products (ProductName, Price, StockQuantity) values('Wireless Mouse', 25.99, 100);
ProductID  ProductName      Price     StockQuantity
301        USB Keyboard     19.99     50           
302        Wireless Mouse   25.99     100           
----------------------------------------------------------------------------------------------------------------------------
Solution 4 : INSERT INTO orders (CustomerID, OrderDate, Status)  VALUES(5, CURRENT_DATE,'Pending');
OrderID  CustomerID  OrderDate    Status 
103          5       2025-07-28   Pending 
-------------------------------------------------------------------------------------------------------------------------

Solution 5 : UPDATE products SET StockQuantity = 0 WHERE StockQuantity  < 0 ;
ProductID    ProductName     Price    StockQuantity 
301          USB Keyboard    19.99    50            
302          HDMI Cable      10.99    0             
--------------------------------------------------------------------------------------------------------------------------
Solution 6 :  DELETE FROM orders WHERE Status = 'Cancelled' AND OrderDate >=  '2023-01-01' AND OrderDate < '2024-01-01' ;
OrderID    CustomerID    OrderDate      Status    
105            3         2022-12-25     Cancelled 
106            4         2023-03-10     Completed 
-------------------------------------------------------------------------------------------------------------------------------
Solution 7 : UPDATE Customers SET City = 'San Francisco' WHERE customerID=3 ;
CustomerID    Name            City          
3             Alice Smith     San Francisco 
---------------------------------------------------------------------------------------------------------------



(Q1)Find Employees Earning More Than Their Manager 
employees(id,name,salary,manager_id)
id  name   salary  manager_id
1   alice  2000     2
2   bob    3000     2
---------------------------------------------------
SELECT  e.name  AS employee_name, 
FROM employees e
JOIN employees m ON e.manager_id = m.id
WHERE e.salary > m.salary;
employee_name
---------------------------------------------------------------
(Q2)Second Highest Salary Per Department
employees(id,name,salary,department_id)
1  alice  2000 2
2  bob    3000 2
3  rahul  40000 1
3  megha  2000 1
----------------------------------------------------------------------
SELECT  e.department_id, MAX(e.salary)  AS second_highest_salary 
FROM employees e
WHERE e.salary <(
   SELECT MAX(salary)
   FROM employees
   WHERE department_id = e.department_id
)GROUP BY e.department_id;
-------------------------------
(Q3)Detect Consecutive Days Of Login per user using (i)SELF-JOINING with date difference logic, (ii)Window functions(Best for modern sql engine).
logins(user_id, login_date)
Difference between Concurrency & parallelism in transaction?
----------------------------------------------------------------------
SELECT DISTINCT l1.user_id
FROM logins l1
JOIN logins l2 ON l1.user_id = l2.user_id AND l2.login_date = l1.login_date + INTERVAL '1 day'    26-7-2025=25-7-2025+1day
JOIN logins l3 ON l1.user_id=  l3.user_id AND l3.login_date = l1.login_date + INTERVAL '2 day';   27-7-2025=25-7-2025+1day   L1->L2->l3
----------------------------------------------------------------------------------------------------------
Order of Execution: FROM(including JOINs) - ON - WHERE - GROUP BY - HAVING - SELECT - DISTINCT - ORDER BY
----------------------------------------------------------------------------------------------------------

Array & Strings are kind of data structure:
All elements of array should be of same type like INTEGERS, STRINGS, CHARACTERS
All elements stored in contiguous memeory location
(1010)2 = (0000 0000 0000 1010)
How To access any particular element in array?

1 2 3 4 5 6 7
2000  20002  2004  2006  2008 2010 2012
base address(assume for learning purpose )bcoz we can't have any control over that- 
by default allocated in computer whereever memory space is there,
size if integer is compiler dependent
CONCEPT OF ADDRESS CALCULATION :
BASE ADDRESS + (NO OF ELEMENTS NEEDS TO BE SKIPEED)*SIZE OF ELEMENTS
1000 + 5 *2)=

*******11Aug-21Aug*****************************************************************************************************************************
Q1)Database Schema:
Customers-CustomerID INT PRIMARY KEY- Name VARCHAR(100)
Orders-OrderID INT PRIMARY KEY-CustomerID INT REFERENCES CUSTOMERS(CustomerID)-Status VARCHAR(20)
ArchievedOrders-OrderID INT PRIMARY KEY-CustomerID INT-Status VARCHAR(20)
Returns-ReturnID INT PRIMARY KEY-OrderID INT REFERENCES Orders(OrderID)-Reson VARCHAR(100)
Q1)Which operator returns rows in the first SELECT but not in the second?
(a)UNION  (b)INTERSECT  (c)EXCEPT✔️ (d)JOIN
These operators work on set level.
UNION → combines rows from both SELECT queries (removes duplicates by default).
INTERSECT → returns only rows that are common to both SELECT queries.
EXCEPT → returns rows from the first SELECT query that are not present in the second.
JOIN → combines rows from two tables based on a related column.

Q2)Which query could return unexpected results if ArchievedOrders contains NULL OrderIDs?
(a)SELECT OrderID FROM Orders EXCEPT SELECT OrderID FROM ArchievedOrders.
(b)SELECT OrderID FROM Orders WHERE OrderID NOT IN(SELECT OrderID FROM ArchivedOrders.✔️
(c)Both A and B
(d)Neither

(Q3)Which pair always produces the same result if no NULLs are involved?
(a)UNION and UNION ALL (B)EXCEPT and NOT IN ✔️
(c)INTERSECT and CROSS JOIN  (d)JOIN and UNION
Option (a) UNION vs UNION ALL

UNION removes duplicates, UNION ALL keeps them.
If no NULLs but duplicates exist, the results will differ.
👉 Not always same. ❌

Option (b) EXCEPT vs NOT IN
EXCEPT: returns rows in first query that are not in the second.
NOT IN: does the same, but fails only when NULLs are present in the subquery.
If no NULLs are involved, both give identical results. ✅
👉 This is the correct answer.

Option (c) INTERSECT vs CROSS JOIN
INTERSECT: common rows between two queries.
CROSS JOIN: Cartesian product (all combinations).
👉 Totally different. ❌

Option (d) JOIN vs UNION
JOIN: combines rows horizontally based on condition.
UNION: combines rows vertically (stacking).
👉 Different. ❌

(Q4)In (SELECT Status FROM Orders) EXCEPT (SELECT Status FROM ArchievedOredrs) with NULLs,
what happens?
(a)NULL rows match,so they disappear
(b)NULL rows remain because NULL!=NULL✔️
(c)NULL rows cause error
(d)NULLs convet to empty string

How EXCEPT works with NULLs:
EXCEPT does set subtraction: rows in the first query that are not in the second.
In SQL, NULL is treated as a valid row value in set operations (UNION, INTERSECT, EXCEPT).
But important rule: NULL ≠ NULL in comparisons.
So:
If Orders has a NULL status, and ArchivedOrders also has a NULL status,
EXCEPT will not treat them as equal.
The NULL from Orders will remain in the result.

(Q5)What does INTERSECT return?
(a)All rows in either SELECT (b)Rows that appear in both SELECTs ✔️
(c)Rows only in the first SELECT (d)Rows only in the second SELECT

(Q6)Which is faster for combining two SELECTs when duplicates don't matter?
(a)UNION (b)UNION ALL✔️ (c)INTERSECT (d)EXCEPT

UNION removes duplicates → needs extra sorting / hashing to check for duplicates → slower.
UNION ALL just stacks results from both queries → no duplicate check → faster.
INTERSECT and EXCEPT require comparisons between sets → more expensive than UNION.

(Q7)Which is equivalent to (A UNION B) EXCEPT C?
(a)(A EXCEPT C) UNION (B EXCEPT C)✔️ (b)(A EXCEPT B) INTERSECT C
(c)(A UNION C) UNION B (d)(A UNION B) UNION C
(A UNION B) EXCEPT C Meaning: all rows in A or B, but remove anything that is also in C.
(A EXCEPT C) UNION (B EXCEPT C)

Take A but remove C,
Take B but remove C,
Then combine them.
👉 That’s exactly the same as first doing (A UNION B) and then removing C. ✅

Option (b)
(A EXCEPT B) INTERSECT C
Rows in A but not B, then intersect with C.
👉 Completely different. ❌

Option (c)
(A UNION C) UNION B
That adds C instead of removing it. ❌

Option (d)
(A UNION B) UNION C
Again adds C instead of subtracting. ❌

(Q8)What's wrong with:
SELECT OrderID FROM Orders
UNION
SELECT OrderID FROM ArchivedOrders
OREDR BY Status
(a)Nothing;sort by status  (b)Valid only if Status in SELECT
(c)ORDER BY can go anywhere  (d)Works only with GROUP BY

Both subqueries only select OrderID.
Final result set has just one column: OrderID.
But the query tries ORDER BY Status.
Status is not part of the result set, so SQL throws an error.
Options:
(a) Nothing; sort by status → ❌ Wrong (not possible, Status not in result).
(b) Valid only if Status in SELECT → ✅ Correct, because you can only sort by output columns or their aliases.
(c) ORDER BY can go anywhere → ❌ Wrong, ORDER BY must be at the end of the whole UNION query.
(d) Works only with GROUP BY → ❌ Irrelevant, GROUP BY not required here.

(Q9)Which query finds orders returned but not archived?
(a)SELECT OrderID FROM Returns INTERSECT SELECT OrderID FROM ArchivedOrders
(b)SELECT OrderID FROM Returns EXCEPT SELECT OrderID FROM ArchivedOrders
(c)SELECT OrderID FROM Returns UNION SELECT OrderID FROM ArchivedOrders
(d)SELECT OrderID FROM Returns JOIN ArchivedOrders USING(OrderID)
Option (a)
SELECT OrderID FROM Returns 
INTERSECT 
SELECT OrderID FROM ArchivedOrders;
👉 Finds orders that are both returned and archived. ❌ Not what we want.

Option (b)
SELECT OrderID FROM Returns 
EXCEPT 
SELECT OrderID FROM ArchivedOrders;
👉 Finds orders that are in Returns but not in ArchivedOrders. ✅ Exactly what we want.

Option (c)
SELECT OrderID FROM Returns 
UNION 
SELECT OrderID FROM ArchivedOrders;
👉 Combines both sets (all returned + all archived). ❌ Wrong.

Option (d)
SELECT OrderID FROM Returns 
JOIN ArchivedOrders USING(OrderID);
👉 Finds only orders that are both returned and archived. ❌ Wrong.

(Q10)When combining two SELECT with different columns:
(a)UNION will still work  (b)UNION fails with syntax error✔️
(c)INTERSECT merges automatically (d)EXCEPT ignores extra columns
Rule for set operators (UNION, UNION ALL, INTERSECT, EXCEPT):
Both SELECT statements must return the same number of columns.
The columns must have compatible data types (so they can be compared).
Otherwise → SQL gives a syntax error.

Options:
(a) UNION will still work → ❌ No, UNION requires same columns.
(b) UNION fails with syntax error → ✅ Correct, if column counts differ.
(c) INTERSECT merges automatically → ❌ No auto-merge, same rule applies.
(d) EXCEPT ignores extra columns → ❌ It doesn’t ignore, it also requires same columns.

(Q11)Which guarantees no duplicate rows in output?
(a)UNION ALL (b)UNION✔️ (c)CROSS JOIN  (D)None

(Q12)Which placement of ORDER BY is valid for UNION?
(a)After each SELECT  (b)Only after final SELECT ✔️
(c)Anywhere (d)In FROM clause
For UNION, you can only use ORDER BY once, and it must be placed after the final SELECT statement to sort the combined result set.

(Q13)How does UNION differ from JOIN fundamentally?
(a)UNION stacks rows vertcally; JOIN combines horizontally.✔️
(b)They are equivalent
(c)JOIN removes duplicates automaically
(d)UNION only works for same table.

(Q12)Which placement of ORDER BY is valid for UNION?
(a)After each SELECT  (b)Only after final SELECT
(c)Anywhere (d)In FROM clause to sort the combined result set.

(Q14)If you want Orders that exist in Orders but not in both ArchievedOrders and Returns, which is correct?
(a)Orders EXCEPT(ArchivedOrders INTERSECT Returns)
(b)(Orders Except ArchivedOredrs) UNION Returns
(c)Orders UNION ArchivedOredrs UNION Returns
(d)Orders INTERSECT(ArchivedOredrs EXCEPT Returns)

(Q15)You need to find oredrs that are neither archived nor returned.Which of these is equivalent to:
SELECT OrderID FROM Orders
EXCEPT
(SELECT OrderID FROM ArhivedOrders 
 UNION SELECT OrderID FORM Returns);
(a)(Orders EXCEPT ArchivedOrders)EXCEPT Returns  (b)(Orders EXCEPT Returns)Union ArchivedOrders
(c)(Orders INTERSECT ArchivedOrders) EXCEPT Returns (d)(Orders UNION ArchivedOrders)EXCEPT Returns
Step 1: Meaning
This takes all Orders
Removes anything that appears in ArchivedOrders OR Returns (the union).
So the result = Orders that are neither archived nor returned ✅

Step 2: Check options
(a) (Orders EXCEPT ArchivedOrders) EXCEPT Returns
First removes ArchivedOrders
Then removes Returns
Equivalent to removing (ArchivedOrders ∪ Returns)
✅ This matches exactly.

(b) (Orders EXCEPT Returns) UNION ArchivedOrders
Wrong: Brings back ArchivedOrders.

(c) (Orders INTERSECT ArchivedOrders) EXCEPT Returns
Wrong: Keeps only intersection with ArchivedOrders first.

(d) (Orders UNION ArchivedOrders) EXCEPT Returns
Wrong: Adds ArchivedOrders instead of removing.

(Q16)Departments-DeptID(Primary Key)-DeptName-Location
Employees-EmpID(Primary Key - EmpName -DeptID(Foreign Key to Departments)-ManagerID
(Foreign Key to Employees, for self-reference)-Salary 
Projects-ProjectID(Primary Key)- ProjectName-Budget

You need to create a report listing every single employee and their department name.
If an employee has not yet been assigned a department,they should still appear in the report.which join is most appropriate?
(a)INNER JOIN (b)LEFT JOIN from Employees to Departments
(c)RIGHT JOIN Ffrom Employees to Deartments  (d)CROSS JOIN
Every single employee should appear.
If no department assigned, still include the employee (with NULL for DeptName).
That means we keep all rows from Employees table, and join department info only if available.
👉 This is exactly what a LEFT JOIN from Employees to Departments does.

(Q17)What is the primary risk of writing a JOIN clause without a corresponding ON clause?
(a)It will always result in asyntax error.
(b)It will perform a LEFT JOIN by default.
(c)It will produce a Cartesian Product(CROSS JOIN),potentially gebnerating a massive ,incorrect result set.
(d)It will only return rows from the first table.
If you write a JOIN without an ON clause:
SQL doesn’t know how to match rows.
It falls back to combining every row of the first table with every row of the second table → this is a Cartesian Product (CROSS JOIN).
That can create a huge, incorrect result set.
✅ Correct answer: (c) It will produce a Cartesian Product (CROSS JOIN), potentially generating a massive, incorrect result set.

(Q18)A query performs a LEFT JOIN from TableA to TableB. If you  add a condition WHERE TableB.column='some value',
what is the potential effect on the query?
(a)It has no effect on the join type. 
(b)It can efficiently turn the LEFT JOIN into an INNER JOIN because it filters out rows where TableB.column would have been NULL.✔️
(c)It will cause a syntax error.
(d)It converts the join into a RIGHT JOIN.

(Q19)For optimizing join performance,what is the most critica factor?
(a)Using table aliases for every table.  (b)Ensuring the columns used in the ON clause are properly indexed.
(c)Writing all keywords in uppercase.  (d)Using RIGHT JOIN instaed of LEFT JOIN.
When optimizing join performance, the key is:
The database must quickly match rows between the joined tables.
That depends on whether the columns in the ON clause are indexed.
Aliases, uppercase, or changing LEFT/RIGHT JOIN don’t affect performance meaningfully.
✅ Correct answer: (b) Ensuring the columns used in the ON clause are properly indexed.

(Q20)You want to find all departments where the average employee salary is greater than $75000.
which clause is necessary to filter the groups based on this aggregate condition?
(a)WHERE AVG(Salary)>75000  (b)ON AVG(Salary)>75000  
(c)HAVING AVG(E.Salary)>75000 ✔️ (d)FILTER(AVG(Salary)>75000)
When filtering aggregate results (like AVG, SUM, COUNT):
WHERE filters rows before grouping → can’t use aggregate functions.
ON is only for join conditions.
HAVING is used to filter groups after aggregation.
FILTER(...) is not standard SQL for this case.
So the correct clause is:
✅ (c) HAVING AVG(E.Salary) > 75000

(Q21)You need to create a report listing every single employee and their department name.
If an employee has not yet been assigned a deprtment,they should still appear in the report.
Which join is most appropriate?
(a)INNER JOIN  (b)LEFT JOIN from Employees to departments
(c)RIGHT JOIN from Employees to Departments (d)CROSS JOIN
We want all employees listed, even if they don’t have a department yet.
INNER JOIN → drops employees without a department ❌
RIGHT JOIN from Employees to Departments → keeps all departments, not all employees ❌
CROSS JOIN → makes a Cartesian product ❌
LEFT JOIN from Employees to Departments → keeps all employees, adds department name if available ✅

(Q22)What will this query return?
SELECT E.EmpName, M.EmpName
FROM Employees E
JOIN Employees M ON E.ManagerID = M.EmpID;
(a)A list of all employees and their managers,including the CEO who has no manager.
(b)A list of employees who are also managers.
(c)A list of employees and their direct managers,excluding employees who do not have a manager.✔️
(d)A list of all possible employee-manager pairings.
This is a self-join:
E = employee , M = manager (another row in the same table)
Join condition: E.ManagerID = M.EmpID
This means we only get employees who have a manager.
Employees without a manager (e.g., CEO with ManagerID = NULL) are excluded.
Result: pairs of (Employee, Manager) for every employee with a manager.

(Q23)To find all departments that currently have no employees,which query is effective?
(a)SELECT D.DeptName FROM Departments D INNER JOIN Employees E ON D.DeptID=E.DeptID WHERE E.EmpID IS NULL;
(b)SELECT D.DeptName FORM Departemnts D LEFT JOIN Employees E ON D.DeptID = E.DepID WHERE E.EmpID IS NULL;
(c)SELECT D.DeptName FROM Departments D FULL OUTERJOIN Employees E ON D.DeptID=E.DeptID;
(d)SELECT D.DeptName FROM Departments D CROSS JOIN Employees E;
We want departments that have no employees.
(a) INNER JOIN ... WHERE E.EmpID IS NULL → impossible, inner join removes NULL matches ❌
(b) LEFT JOIN ... WHERE E.EmpID IS NULL → correct: keeps all departments, filters those without employees ✅
(c) FULL OUTER JOIN → would include all, but doesn’t filter ❌
(d) CROSS JOIN → Cartesian product, not relevant ❌

(Q24)What is the primary risk of writing A join clause without a corresponding ON clause?
(a)It will always result in a syntax error.  
(b)It will perform a LEFT JOIN by default.
✔️(c)It will produce a Cartesian Product(CROSS JOIN),potentially generating a massive, incorrect result set.
(d)It will only return  rows from the first table.

(Q25)You want to list all projects with a budget over $500,000 and the names of the employees working on them.
If a project meets the budget criteria but has no employees assigned,it should not appear in the list.Which join strategy is correct?
(a)Start with Projects,LEFT JOIN to EmployeeProjects,then LEFTJOIN to Employees, and filter in the WHERE clause.
(b)Start with Projects,INNER JOIN to EmployeeProjects,then INNERJOIN to Employees, and filter in the WHERE clause.✔️
(c)Start with Projects,RIGHT JOIN to EmployeeProjects,then INNER JOIN to Employees, and filter in the WHERE clause.
(d)Use a FULL OUTER JOIN across all three tables.
We want:
Projects with budget > 500,000
Must list employees working on them
If a project has no employees, it should NOT appear
That means:
We only want projects that have matching employees → so we must use INNER JOIN (not LEFT JOIN, because LEFT JOIN would include projects with no employees).
The filtering on budget goes in the WHERE clause.

(Q26)A query performs a LEFT JOIN from TableA to TableB. If you add a condition WHERE TableB.column='some value', what is the potential effect on the query?
(a)It has no effect on the join type.
(b)It can effectively turn the LEFT JOIN into an INNER JOIN because it filters out rows where TableB.
column would have been NULL.
(c)It will cause a syntax error.
(d)It converts the join into a RIGHT JOIN.
LEFT JOIN keeps all rows from TableA, and matches from TableB when possible.
If no match, TableB columns are NULL.
But if we add a condition in the WHERE clause like:
WHERE TableB.column = 'some value'
Then rows where TableB.column is NULL (unmatched) will be excluded.
This removes the effect of the LEFT JOIN, making it behave like an INNER JOIN.

(Q27)To get a complete list of every employee and every project,
linking them where a relationship exist but including all non-linked rows from both sides,which join should be used?
(a)INNER JOIN   (b)CROSS JOIN  (c)LEFT JOIN  (d)FULL OUTER JOIN
We want:
Every employee
Every project
Link them where relationships exist
But also include all non-linked rows from both sides
👉 That’s exactly what a FULL OUTER JOIN does (keeps all rows from both tables, with NULLs where no match).

(Q28)You need to find the manager of an employee's manager(i.e, the "grand-manager"). This requires:
(a)A single SELF JOIN.
(b)Two consecutive SELF JOINs on the Employees table.✔️
(c)A CROSS JOIN and a SELF JOIN
(d)Joining Employees to Departments.
We want the grand-manager (manager of an employee’s manager).
A single self join gives: Employee → Manager.
To go one step further (Manager → Manager’s Manager), we need two levels of self join.
So:
✅ Correct answer: (b) Two consecutive SELF JOINs on the Employees table.

(Q29)If TableA has 100 rows and TableB has 50 rows,
what is the maximum number of rows a LEFT JOIN from TableA to TableB can produce?
(a)100 (b)50  (c)5000  (d)More than 100, if there are multiple matches in TableB for rows in TableA.
For a LEFT JOIN from TableA (100 rows) to TableB (50 rows):
Every row in TableA will appear at least once (so minimum = 100).
If each row in TableA matches multiple rows in TableB, the result can have more than 100 rows.
In the extreme, if every row in TableA matches all 50 rows in TableB → 100 × 50 = 5000 rows.
So the maximum is more than 100, depending on matches.

(Q30)For optimizing join performance, what is the most critical factor?
(a)Using table aliases for every table.
(b)Ensuring the columns used in the ON clause are properly indexed. ✔️
(c)Writing all keywords in uppercase.
(d)Using RIGHT JOIN instead of LEFT JOIN.
For join performance:
SQL engines optimize query execution internally, so aliases (a) or uppercase (c) don’t matter.
LEFT vs RIGHT JOIN (d) has no real performance difference.
The critical factor is making sure the join columns are indexed, so row matching is fast.

(Q31)You need to find all employees in the 'Sales' department who are not assigned to the 'Alpha' project. which logic is correct?
(a)INNER JOIN Employees and Departments, then LEFT JOIN to EmployeeProjects/Projects and check for a NULL or non-matching project name.
(b)Use a FULL OUTER JOIN nad filter in the WHERE clause.
(c)Use a FULL OUTER JOIN  and filter in the WHERE clause.
(d)Use a subquery with NOT IN to exclude employees on the 'Alpha' project.
(a) is partially correct, but to be safe you need to ensure the employee has no Alpha assignment at all. It can be error-prone without grouping.
(b) & (c) — FULL OUTER JOINs are unnecessary and inefficient for this use case ❌
(d) — Use a subquery with NOT IN to exclude employees on the 'Alpha' project ✅

(Q32)Cinsider the query:
SELECT D.DeptName , COUNT(E.EmpID)
FROM Departments D
LEFT JOIN Employees E ON D.DeptID = E.DeptID
GROUP BY D.DeptName;
What does COUNT(E.EmpID) calculate?
(a)It counts all employees in e ach department, and will show 1 for departemnts with no employees.
(b)It counts all non-null EmpIDs for each department, resulting in 0 for departments with no employees.
(c)It will produce an error beacuse you cannot use COUNT with a LEFT JOIN.
(d)It counts the total number of employees in the comppany for each department row.
LEFT JOIN → keeps all departments, even those without employees.
COUNT(E.EmpID) → counts only non-NULL values of EmpID.
If a department has no employees, E.EmpID is NULL, so the count = 0 (not 1).
So the result is: number of employees per department, showing 0 for departments with no employees.
✅ Correct answer:
(b) It counts all non-null EmpIDs for each department, resulting in 0 for departments with no employees.

(Q33)To find all employees who have the same manager as the employee named 'John Smith', what is the best approach?
(a)A CROSS JOIN on the Employees table.
(b)A SELF JOIN where you first find 'John Smith's manager's ID and then find all employees with that same ID, excluding ;John Smith' himself.
(c)A LEFT JOIN to the Departments table.
(d)A query with a GROUP BY clause on the ManagerID.
We want:
Employees who share the same Manager as 'John Smith'.
Best approach:
First, find 'John Smith'’s ManagerID.
Then select all employees whose ManagerID = that value.
Exclude 'John Smith' himself.
That’s exactly a SELF JOIN approach (b).
✅ Correct answer:
(b) A SELF JOIN where you first find 'John Smith's manager's ID and then find all employees with that same ID, excluding 'John Smith' himself.

(Q34)When joining Employees to EmployyProjects, what is the relationship type and how does it affect the join?
(a)One-to-One;each employee row can only join with one project row.
(b)One-to-Many; an employee can appear multiple times in the result set if they are on multiple projects.
(c)Many-to-Many;requires a third linking table to join them.
(d)It's a self-referencing relationship.
Employees table: each employee has one row.
Projects table: each project has one row.
The relationship between employees and projects is many-to-many (an employee can work on many projects, and a project can have many employees).
To represent this, we use a linking table (EmployeeProjects).
So when joining Employees → EmployeeProjects:
The relationship is one-to-many (one employee → many rows in EmployeeProjects).
This means an employee can appear multiple times in the join result, once for each project they’re assigned to.
✅ Correct answer:
(b) One-to-Many; an employee can appear multiple times in the result set if they are on multiple projects.
                       
(Q35)You want to find all departments where the average employee salary is graeter than $75,000.Which clause is necessary to filter the groups based on this aggregate condition?
(a)WHERE AVG(Salary)>75000   (b)ON AVG(Salary)>75000  
(c)HAVING AVG(E.Salary)>75000  (d)FILTER(AVG(Salary>75000)
When filtering aggregates like AVG(), you must use the HAVING clause (since WHERE works only on individual rows before grouping).
✅ Correct answer:
(c) HAVING AVG(E.Salary) > 75000
                       
                       
                       
                       











































